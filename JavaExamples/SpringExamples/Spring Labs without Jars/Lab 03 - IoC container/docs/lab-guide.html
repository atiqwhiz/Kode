<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="Lab3.DivingdeepinsidetheIoCcontainer">Lab 3. Diving deep inside the IoC container</h1><h1 id="Spring3.0enhancements">Spring 3.0 enhancements</h1><p>The first thing we will do is check out some of the new features introduced in Spring 3.0.</p><h2 id="UsingEL">Using EL</h2><h3 id="Exercise1.UsingELinxmlconfiguration">Exercise 1. Using EL in xml configuration</h3><p>Expressions, <em>#{expr}</em> can now be used throughout the framework now from 3.0 onwards. It&#8217;s the easiest way possible now for setting bean properties wherever possible.</p><p>We will do a small example in which we will see how to conveniently read system properties using EL notations. Start by reviewing <code>ErrorHandler</code> class from <code>ex1</code> package. According the code, we need to initialize the <em>defaultLocale</em> property. Open <code>ex1-config-1.xml</code> file and complete <code>TODO 1</code> by referring to <b>slide no. 102</b> to use EL for initializing the <em>defaultLocale</em>.</p><p>Run the <code>ErrorHandlerTest</code> class to test whether EL is working or not.</p><h3 id="Exercise2.UsingELviaannotations">Exercise 2. Using EL via annotations</h3><p>We need to use <em>@Value</em> annotation to initialize bean properties using EL. The advantage of this annotation is also the same as other annotations, it can be used at the field level directly. Open <code>ErrorHandler2</code> class and complete <code>TODO 2</code> by referring to <b>slide no. 103</b>. </p><p>Run <code>ErrorHandlerTest2</code> to see if @Value annotation is working or not.</p><h2 id="Exercise3.Annotationbasedcontainermetadata">Exercise 3. Annotation based container metadata </h2><p>Refer to <b>slide no. 104-105</b> for details.</p><p>Review <code>AppConfig</code> class from <code>ex2</code> package carefully and see if you are clear with the intent of this code. Also review the other dependent classes as well. Refer to <b>slide no. 106</b> for details.</p><p>Open <code>AppConfigTest</code> class and see how this time we created an ApplicationContext instance without supplying an xml. Refer to <b>slide no. 107</b> for details. Run the test class and see if you are clear with the working of the same.</p><p>Try using autowiring as mentioned on <b>slide no. 106</b>. Also try creating an xml file to create an ApplicationContext instance according to the instructions mentioned on <b>slide no. 107</b>.</p><h1 id="Lifecyclemanagement">Lifecycle management</h1><p>In this section, we will review the lifecycle of beans managed by the container as well as the extension points available to manage the container&#8217;s lifecycle.</p><h2 id="Exercise4.Beanlifecycle">Exercise 4. Bean lifecycle</h2><p>Any spring managed object can receive callbacks from the container to perform initialization and cleanup operations. There are different ways to deal with it as mentioned in <b>slide no. 109</b>. </p><p>Review <code>LifecycleBean</code> , <code>LifecycleBean2</code> and <code>LifecycleBean3</code> class from <code>ex3</code> package to identify different ways of managing a beans lifecycle. Run the <code>LifecycleTest</code> class so that you will be able to test the same. Refer <b>slide no. 110-113</b> for details.</p><h2 id="Exercise5.Containerlevellifecycleextensions">Exercise 5. Container level lifecycle extensions</h2><p>Refer <b>slide no. 116</b> for details about the lifecycle activities of an IoC container. Understanding the lifecycle is complex and at the same time very interesting. Start by carefully reviewing <em>all the java classes</em> one by one from the <code>ex4</code> package. Refer to the appropriate slides about details on the relevant implementations. You need to run the <code>LifecycleTest</code> class to see the complete lifecycle in action. Take your time and don&#8217;t be in a hurry. According to me, this is one of the most important examples on IoC. By the time you complete this example, you will be able to easily extend the capabilities of the IoC container with the help of the different interfaces used in this example here.</p><h3 id="Exercise6.ExampleonRequiredAnnotationBeanPostProcessor">Exercise 6. Example on RequiredAnnotationBeanPostProcessor</h3><p>This is a ready to use BeanPostProcessor implementation. Start by reviewing the <code>BankServiceImpl</code> class. As you can see we are using the <em>@Required</em> annotation here. Refer to <b>slide no. 121-123</b> for details. So according the code, both the dependencies need to be injected or else we should get an error. We will now test this behavior and see if is true. Run the <code>RequiredAnnotationTest</code> class and confirm.</p><h3 id="Exercise7.Raisingacustomevent">Exercise 7. Raising a custom event</h3><p>In this example, we will see how to raise an event from the code. Refer to <b>slide no. 135</b> for details. Start by reviewing <code>BlackListEvent</code> , <code>EmailBean</code> and <code>BlackListNotifier</code> classes to understand the scenario. Refer to <b>slide no. 136-138</b> for details. <code>ex6-config.xml</code> file contains the configuration of these beans. Review the configuration and see if is is okay. To test the working, you need to run the <code>CustomEventTest</code> class.</p><p>Apart from this you can also review <code>ContextClosedListener</code> class which is yet another example on writing listeners in Spring.</p><h1 id="Exercise8.CreatingcustomscopesinSpring">Exercise 8. Creating custom scopes in Spring</h1><p>In this section, we will have a quick look at how to create our own &#8220;thread&#8221; scope implementation. Open <code>ThreadScope</code> class and review the code. <code>ex7-config.xml</code> contains the configuration required for registering custom scopes. We have a small <code>EmployeeService</code> class which we will bind it to <code>thread</code> scope. This  time for testing purpose, i haven&#8217;t written a Test class, it&#8217;s a plain Java class with the <em>main</em> method. The name of the class is <code>CustomScopeTest</code>. To test whether &#8220;thread&#8221; scope is working or not, i have created couple of threads and what should happen is, for each thread one instance of <em>EmployeeService</em> should get created. Review the test class to confirm the same.</p><h1 id="Exercise9.Creatingcustomnamespacesinspring">Exercise 9. Creating custom namespaces in spring</h1><p>There are multiple steps to follow for creating a custom namespace in Spring. <b>slide no. 146-150</b> contains details about these steps. </p><ol><li>Creating a schema definition file <em>(myspring.xsd)</em> </li><li>Map the logical namespace URI to the physical xsd file <em>(META-INF/spring.schemas)</em></li><li>Map the namespace to a namespace handler class in Spring <em>(META-INF/spring.handlers)</em> &amp; _(ex8/CustomNamespaceHandler.java) </li><li>Map each custom tag/element in the namespace with the Parser class (ex8/MyDatabaseBeanDefinitionParser.java)</li><li>Use the namespace like any other namespace in your configuration file (ex8/ex8-config.xml)</li></ol><p>Review the steps. See to it that you are comfortable with the steps and then proceed towards the testing. The name of the test class is <code>CustomNamespaceTest</code>.</p><h1 id="Conclusion">Conclusion</h1><p>In this very important lab, we saw lot&#8217;s of customization possible in Spring framework. With every version the list of improvements keeps on increasing. We also saw some of the features of Spring 3. Plus we discussed about  lifecycle methods, event handling and other core customizations. In the next lab, we will review some more features provided by the IoC container.</p></body></html>