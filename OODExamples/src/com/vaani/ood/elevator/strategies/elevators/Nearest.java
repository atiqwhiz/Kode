package com.vaani.ood.elevator.strategies.elevators;

import java.util.ArrayList;
import com.vaani.ood.elevator.main.Console;
import com.vaani.ood.elevator.models.Elevator;
import com.vaani.ood.elevator.models.Passenger;
import com.vaani.ood.elevator.strategies.ElevatorStrategy;

public class Nearest extends ElevatorStrategy {

	public Nearest() {
		super();
	}

	public Nearest(Elevator elevator) {
		super(elevator);
	}

	@Override
	public String getName() {
		return "Nearest : Comportement qui choisit l'étage (ou il y a quelque chose à faire) le plus proche de lui.";
	}

	@Override
	public Class getType() {
		return ElevatorStrategy.class;
	}

	@Override
	public void acts() {
		// Aucun appel, on ne fait rien, on est a l'arret, tout va bien
		if(!elevator.getBuilding().allPassengersAreArrived() && (elevator.getBuilding().getWaitingPersonsCount() != 0 || elevator.getPassengerCount() != 0)) {

			// Si on n'a pas encore d'étage visé ou que l'on est arrivé a l'étage visé
			// on s'arrete et on commence le travail
			if((elevator.getTargetFloor() == Integer.MAX_VALUE) || (elevator.getCurrentFloor() == elevator.getTargetFloor())) {
				elevator.setMoving(false);

				// Ceux qui veulent descendre desendent
				elevator.releaseAllArrivedPassengers();

				// Si l'ascenseur n'est pas plein et qu'il ne doit pas partir de suite...
				if(!elevator.isFull() && !must_leave_now) {
					int i = 0;
					// Tant que l'ascenseur n'est pas plein ou en alerte et qu'on a pas testé tous
					// les passagers qui attendent à l'étage, on entre dans la boucle
					while(!elevator.isFull() && !elevator.isInAlert() && i < elevator.getBuilding().getWaitingPersonsCountAtFloor(elevator.getCurrentFloor())) {
						// On récupre le ime passager qui attend à l'étage pour lui permettre
						// d'essayer de rentrer (si différent de null)
						Passenger p = elevator.getBuilding().getWaitingPassengerAtFloorWithIndex(elevator.getCurrentFloor(), i);
						if(p != null) p.canEnterElevator(elevator);
						i++;
					}
				}

				// On récupre la liste des etages demandés par les passagers de l'ascenseur
				ArrayList<Integer> tabWanted = elevator.getFloorsWanted();

				// Si l'ascenseur n'est pas plein ou en alerte, on fusionne cette liste
				// avec la liste des étages ou des passagers attendent
				if(!elevator.isFull() && !elevator.isInAlert()) {
					ArrayList<Integer> tabWaiting = elevator.getBuilding().getFloorWithWaitingPassengers();
					// Merge des deux listes
					for (Integer i : tabWaiting) {
						if(!tabWanted.contains(i)){
							tabWanted.add(i);
						}
					}
				}

				// On sélectionne un étage au hasard et on change le targetFloor de l'ascenseur
				int target_floor;
				if(!tabWanted.isEmpty()) {
					int nearest_floor = elevator.atTop() ? elevator.getCurrentFloor()-1 : (elevator.atBottom() ? elevator.getCurrentFloor()+1 : elevator.getCurrentFloor()+1);
					int min_distance = Integer.MAX_VALUE;
					for (Integer floor : tabWanted) {
						if(Math.sqrt((elevator.getCurrentFloor()-floor)*(elevator.getCurrentFloor()-floor)) < min_distance) {
							min_distance = (int) Math.sqrt( (elevator.getCurrentFloor()-floor)*(elevator.getCurrentFloor()-floor) );
							nearest_floor = floor;
						}
					}
					target_floor = nearest_floor;
					elevator.setTargetFloor(target_floor);
				}
			}

			elevator.incrementStoppedTime(1);
			if((elevator.getStoppedTime() >= elevator.getStopTime())) elevator.leaveThisFloor();
		}
		else {
			elevator.setMoving(false);
		}
	}

	@Override
	public boolean takePassenger(Passenger passenger) {
		elevator.incrementStopTime(5*passenger.getPersonCount());
		return true;
	}

	@Override
	public void releasePassenger(Passenger passenger) {
		elevator.incrementStopTime(5*passenger.getPersonCount());
		Console.debug("Un passager descend. "+passenger.getCurrentFloor()+" -> "+passenger.getWantedFloor()+" "+passenger.isInTheElevator()+" "+passenger.isArrived());
	}

	@Override
	public void leaveThisFloor() {
	}

}
